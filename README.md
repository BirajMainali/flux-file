# FluxFile: Chunked File Upload Solution

**FluxFile** is a modular, customizable, and extensible file upload solution designed to handle large files by breaking them into manageable chunks. It provides flexibility in choosing the storage backend, making it easy to integrate with a variety of storage systems, such as local file systems, cloud storage (e.g., Azure Blob Storage, AWS S3), or even custom storage solutions.

## Key Features

- **Chunked Uploads**: Efficiently uploads large files in smaller chunks to avoid memory and network overloads.
- **Customizable Storage Providers**: Easily switch between different storage backends (e.g., local file system, cloud storage).
- **Pluggable Architecture**: Core services and storage providers are interchangeable, enabling flexibility for specific use cases.

---

## Core Components

### 1. `IFluxFileStorageProvider`

This interface defines the contract for any file storage system used to save, retrieve, and manage file chunks. It can be implemented for any storage backend (local, cloud-based, etc.).

```csharp
public interface IFluxFileStorageProvider
{
    Task<string> SaveChunkAsync(string fileName, byte[] chunk); // file name that initialy generated by backend e.g hello_word_934839483.pdf. Without chunk information.
    Task<byte[]> GetAllChunksAsync(string searchPattern);
    Task DeleteChunkAsync(string fileName);
    Task<string[]> GetAllChunkPathsAsync(string searchPattern);
}
```

### 2. `IFluxFileUploadService`

This service manages the high-level file upload process, working with the storage provider to handle chunk uploads, completion, and cancellation.

```csharp
public interface IFluxFileUploadService
{
    Task<string> StartUploadAsync(string fileName);
    Task<string> UploadChunkAsync(string fileIdentifier, byte[] chunk, long chunkIndex);
    Task CompleteUploadAsync(string fileIdentifier);
    Task CancelUploadAsync(string fileIdentifier);
}
```

---

## How It Works

### 1. **Starting an Upload**

The client initializes the upload process by sending the file name, and the server generates a unique identifier for this upload session. The identifier is used to track the file chunks that will be uploaded.

```csharp
app.MapPost("/upload/start", async ([FromForm] string fileName, IFluxFileUploadService uploadService) =>
{
    try
    {
        var uniqueFileName = await uploadService.StartUploadAsync(fileName);
        return Results.Ok(uniqueFileName);
    }
    catch (Exception ex)
    {
        await uploadService.CancelUploadAsync(fileName);
        return Results.Problem(ex.Message);
    }
}).DisableAntiforgery();
```

### 2. **Uploading Chunks**

The file is split into chunks, and each chunk is uploaded sequentially to the backend. The service processes each chunk and saves it using the storage provider.

```csharp
app.MapPost("/upload", async ([FromForm] string fileName, [FromForm] IFormFile file, [FromForm] long index,
    IFluxFileUploadService uploadService) =>
{
    try
    {
        var chunkFilePath = await uploadService.UploadChunkAsync(fileName, file.ToBytes(), index);
        return Results.Ok(chunkFilePath);
    }
    catch (Exception ex)
    {
        return Results.Problem(ex.Message);
    }
}).DisableAntiforgery();
```

### 3. **Completing the Upload**

Once all the chunks are uploaded, the server finalizes the upload by combining the chunks into the complete file. If the process fails at this stage, the chunks can be deleted or an error message returned.

```csharp
app.MapPost("/upload/complete", async ([FromForm] string fileName, IFluxFileUploadService uploadService) =>
{
    try
    {
        await uploadService.CompleteUploadAsync(fileName);
        return Results.Ok();
    }
    catch (Exception ex)
    {
        await uploadService.CancelUploadAsync(fileName);
        return Results.Problem(ex.Message);
    }
}).DisableAntiforgery();
```

---

## Customizing Storage Providers

A key feature of **FluxFile** is its customizable storage backend. You can implement the `IFluxFileStorageProvider` interface to integrate any storage solution.

### Example: Azure Blob Storage Provider

#### Implementing the Provider

```csharp
public class AzureBlobStorageProvider : IFluxFileStorageProvider
{
    private readonly BlobContainerClient _blobContainerClient;

    public AzureBlobStorageProvider(string connectionString, string containerName)
    {
        _blobContainerClient = new BlobContainerClient(connectionString, containerName);
        _blobContainerClient.CreateIfNotExists();
    }

    public async Task<string> SaveChunkAsync(string fileName, byte[] chunk)
    {
        var blobClient = _blobContainerClient.GetBlobClient(fileName);
        await blobClient.UploadAsync(new BinaryData(chunk), overwrite: true);
        return blobClient.Uri.ToString();
    }

    public async Task<byte[]> GetAllChunksAsync(string searchPattern) // e.g "hello_word_934839483_chunk_*"
    {
        // Retrieve all chunks from Azure Blob Storage based on the pattern
    }

    public async Task DeleteChunkAsync(string fileName)
    {
        var blobClient = _blobContainerClient.GetBlobClient(fileName);
        await blobClient.DeleteIfExistsAsync();
    }

    public async Task<string[]> GetAllChunkPathsAsync(string searchPattern)
    {
        // Retrieve paths of all chunks from Azure Blob Storage
    }
}
```

#### Registering the Provider

To use the Azure provider, register it during the application setup.

```csharp
builder.Services.AddTransient<IFluxFileStorageProvider>(provider =>
{
    var connectionString = "YourAzureBlobConnectionString";
    var containerName = "YourContainerName";
    return new AzureBlobStorageProvider(connectionString, containerName);
});
```

### Example: Custom Storage Provider

You can also create a custom storage provider by implementing the `IFluxFileStorageProvider` interface, allowing you to integrate with any file system or storage service (e.g., AWS S3, Google Cloud Storage).

```csharp
public class CustomStorageProvider : IFluxFileStorageProvider
{
    // Custom logic for SaveChunkAsync, GetAllChunksAsync, DeleteChunkAsync, etc.
}
```

---

## Flexibility and Extensibility

### Modular and Overridable Components

The architecture of **FluxFile** is built to be modular and highly customizable. Every critical step in the upload process, from initializing uploads to storing chunks and finalizing the process, can be overridden. This allows you to adapt **FluxFile** to your unique business needs or infrastructure.

### Example Use Cases

- **Local File Storage**: Save uploaded files to a local directory.
- **Cloud Storage**: Use Azure, AWS S3, or Google Cloud Storage by implementing the relevant `IFluxFileStorageProvider`.
- **Custom Logic**: Implement security, logging, or specific business rules at each stage of the upload process.

---

## Getting Started

1. **Clone the Repository**: Integrate the **FluxFile** system into your project.
2. **Implement a Storage Provider**: Implement `IFluxFileStorageProvider` to work with your chosen storage backend (e.g., Azure, AWS S3, local file system).
3. **Register Services**: Register the necessary services (e.g., `IFluxFileStorageProvider`, `IFluxFileUploadService`) during the application setup.
4. **Set Up API Endpoints**: Use the provided endpoints for handling uploads (`/upload/start`, `/upload`, `/upload/complete`).

---


